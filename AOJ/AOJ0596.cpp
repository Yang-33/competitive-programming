#include "bits/stdc++.h"
using namespace std;
typedef long long ll;

#define FOR(i, s, e) for (ll(i) = (s); (i) < (e); (i)++)
#define debug(x) cout << #x << ": " << x << endl

const ll MOD = 10007;

/* -----  2017/07/07  Problem: AOJ 0596 JOI 2013 (NU contest 14 D)/ Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0595  ----- */
/* ------問題------

OI 高校のプログラミング部には，J 君と O 君と I 君の 3 人の部員がいる． プログラミング部では，部活のスケジュールを組もうとしている．

今，N 日間の活動のスケジュールを決めようとしている．
各活動日のスケジュールとして考えられるものは，各部員については活動に参加するかどうかの 2 通りがあり，部としては全部で 8 通りある．
部室の鍵はただ 1 つだけであり，最初は J 君が持っている．
各活動日には，その日の活動に参加する部員のうちのいずれか 1 人が鍵を持っている必要があり，活動後に参加した部員のいずれかが鍵を持って帰る．

プログラミング部では，活動日には毎回必ず活動が行われるように，あらかじめ各活動日の責任者を定めた．
責任者は，必ずその日の活動に出席しなければならない．

スケジュールを決めようとしている日数と，各活動日の責任者が誰であるかの情報が与えられた時，
すべての活動日に部活動を行うことができるようなスケジュール表として考えられるものの数を 10007 で割った余りを求めるプログラムを作成せよ．
ただし，部活の終了時に鍵を持って帰る部員は，その日の活動に参加している部員の誰でもよく，最終日は誰が鍵を持って帰ってもよいものとする．

-----問題ここまで----- */
/* -----解説等-----

DP+7状態しかないbitDP?
dp[ ある日にちi ][ 来る人の状態j ] := この日iにくる人の状態がjであるときの、今までの組み合わせの総和
としてまわす。
今日来ている人と次の日来る人の少なくとも一人は同じでかつ、ある日の担当が来ていないといけないのでこれをみたすものについて遷移させればよい。

----解説ここまで---- */

ll N;
int dp[10004][8];
int a[10004];
ll ans = 0LL;

int main() {
	cin.tie(0);
	ios_base::sync_with_stdio(false);

	cin >> N;
	string s; cin >> s;
	FOR(i, 0, s.size()) {
		if (s[i] == 'J')a[i] = 0;
		else if (s[i] == 'O')a[i] = 1;
		else if (s[i] == 'I')a[i] = 2;
	}

	dp[0][1] = 1;

	FOR(i, 0, N) {
		FOR(j, 1, 8) {
			FOR(k, 1, 8) {
				if ((j & k) && ((1 << a[i]) & k)) {
					dp[i + 1][k] += dp[i][j];
					dp[i + 1][k] %= MOD;
				}
			}
		}
	}
	FOR(i, 1, 8) {
		ans += dp[N][i];
		ans %= MOD;
	}
	cout << ans << endl;

	return 0;
}
