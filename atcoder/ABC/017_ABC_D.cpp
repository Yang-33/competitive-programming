#include<iostream>
using namespace std;

#define FOR(i,s,e) for(ll (i)=(s);(i)<(e);(i)++)
#define MOD 1000000007
typedef long long ll;

/* -----  2017/03/01  Problem: ABC017 D / Link: http://abc017.contest.atcoder.jp/tasks/abc017_4 ----- */
/* ------問題------

健康志向の高橋君は通販で購入したサプリメントを摂取することにした。
サプリメントは N 個あり、1 から N まで番号が付けられている。
また、サプリメントの味は M 種類あり、1 から M まで番号が付けられている。サプリメント i(1≦i≦N) の味は fi(1≦fi≦M) である。
高橋君はサプリメントを番号順に複数日かけて摂取する予定である。
高橋君はサボらないように、サプリメントが 1 つ以上残っている場合はその日中に必ず 1 つ以上サプリメントを摂取しなければならないという規則を定めた。
高橋君は強靭な肉体を持っているため、1 日にどれだけサプリメントを摂取しても大丈夫だが、
同じ味には飽きてしまうので、同じ日に同じ味のサプリメントを 2 つ以上摂取することはできない。
高橋君は、サプリメントの摂取方法の是非について吟味するため、このような条件下で全部で何通りの摂取方法があるかを知りたい。
ここで 2 つの摂取方法についてそれらが違うというのは、ある日について摂取したサプリメントの番号の組み合わせが異なることを定義する。

-----問題ここまで----- */
/* -----解説等-----

日にちでＤＰかと思ったけど実装がよく分からなかった。
種類でＤＰだった。
dp[ i日目 ] := 総和
とある種類のサプリメントが以前に登場していたら、そこまでのものを差し引く。
そうすることで同じ日に食べるものと食べないものを同時に足すことができる。
これtdpc の駅に似ている。典型かよ。

 ----解説ここまで---- */

ll N, M;
int f[100010];
ll dp[100010];
int num[100010];
ll ans = 0LL;

int main()
{
    cin.tie(0);
    ios_base::sync_with_stdio(false);

    cin >> N >> M;
    FOR(i, 0, N) {
        cin >> f[i];
    }
    ll sum = 1;
    dp[0] = 1;
    int index = 0;

    FOR(i, 0, N) {
        num[f[i]]++;
        while (num[f[i]] > 1) {
            num[f[index]]--;
            sum = (sum + MOD - dp[index]) % MOD;
            index++;
        }
        dp[i + 1] = sum;
        sum = (sum + dp[i + 1]) % MOD;
    }

    ans = dp[N];

    cout << ans << endl;

    return 0;
}