#include<iostream>
#include<algorithm>
using namespace std;

#define FOR(i,s,e) for(ll (i)=(s);(i)<(e);(i)++)
typedef long long ll;

/* -----  2017/02/26  Problem: ABC023 D / Link: http://abc023.contest.atcoder.jp/tasks/abc023_d ----- */
/* ------問題------

高橋君は最近、射撃にハマっている。
高橋君は N 個の風船すべてを射撃で割り、得られる得点をできるだけ小さくする競技に参加している。
風船には 1 から N までの番号が付けられていて、風船 i(1≦i≦N) は競技開始時に高度 Hi のところにあり、1 秒経過するにつれて高度が Si だけ増加する。
高橋君は競技開始時に 1 個風船を割ることができ、そこから 1 秒ごとに 1 個の風船を割ることができる。どの順番で風船を割るのかは高橋君が自由に決定できる。
どの風船についても、その風船を割ることによるペナルティが発生する。ペナルティはその風船が割られたときの高度と等しい整数値となる。高橋君が最終的に得る得点は N 個の風船のペナルティのうちの最大値となる。
高橋君が得ることのできる得点として考えられる最小値を求めよ。

-----問題ここまで----- */
/* -----解説等-----

蟻本より
最大値の最小化。
時間で単純な探索はできないので、ある高さを基準にすべての風船を打ち落とすことは可能かを考える。
これで二分探索を行い、範囲を狭めていく。
t秒後の高さはh+s*t=Xとあらわせるので 高さXに到達するにはt = ( X - h )/s 秒かかる。
つまりt秒かけてもよいということになり、時間をかけられない順に並べ替え、各順番に対して
基準値より低い高さで撃ち落とせるかを確認していく。
上限は2*10^15
二分探索の値でバグをたくさん埋め込んだので理解を深めた。
区間は(l,r]で rが答え

 ----解説ここまで---- */


ll s[100010], h[100010];

bool f(ll x, ll N) {
    ll m[100010];

    FOR(i, 0, N) {
        if (x - h[i] < 0) {
            return false;
        }
        m[i]=((x - h[i]) / s[i]);
    }

    sort(m, m+N);

    FOR(i, 0, N) {
        if (m[i] < i)return false;
    }

    return true;
}

int main()
{
    cin.tie(0);
    ios_base::sync_with_stdio(false);
    
    ll N;
    cin >> N;
    
    FOR(i, 0, N) {
        cin >> h[i] >> s[i];
    }

    ll l = 0;
    ll r = 1000000000000000;

    while (r - l > 1) {
        ll mid = (l + r) / 2;

        if (f(mid, N)) {
            r = mid;
        }
        else {
            l = mid;
        }
    }

    cout << r << endl;

    return 0;
}