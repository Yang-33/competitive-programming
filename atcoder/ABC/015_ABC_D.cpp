#include<iostream>
#include<algorithm>
using namespace std;

#define FOR(i,s,e) for(ll (i)=(s);(i)<(e);(i)++)
typedef long long ll;

/* -----  2017/03/01  Problem: ABC015 D / Link: http://abc015.contest.atcoder.jp/tasks/abc015_4 ----- */
/* ------問題------

高橋くんは、ソフトウエアが期待通りに動いたというエビデンス（証拠）として、画面のスクリーンショットを表計算ソフトに貼り付ける作業を命じられました。 
画面のスクリーンショットは N 枚あり、高さは全て等しいのですが、幅が異なります。 また、表計算ソフトに貼りつけ可能なスクリーンショットには 2 つの制約が存在します。
表計算ソフトの幅は W しかない。そのため、貼りつけるスクリーンショットの幅の合計値は W 以下でなければならない。
表計算ソフトは K 枚より多くのスクリーンショットを貼りつけることが出来ない。よって、表計算ソフトに貼りつけ可能なスクリーンショットは K 枚までである。
さらに、スクリーンショットには「重要度」が存在するため、高橋くんは 2 つの制約を満たしながら、貼り付けるスクリーンショットが持つ重要度の合計値を最大化したいです。 
しかし、彼にとってこの仕事は難しいので、あなたが彼の代わりに表計算ソフトに貼り付け可能なスクリーンショットが持つ重要度の合計の最大値を求めてください。

-----問題ここまで----- */
/* -----解説等-----

いつものｄｐに個数制限がついただけ。典型の中でも典型。
最初は計算量が大きくて重要度を最小重みでやるかと思ったけどそんなことをしなくても間に合った。
dp[ 何番まで選べるか ][ 重さ ][ 何個選んだか ]:=重要度の最大値　として解ける。Ｏ(N*W*K)でぎりぎり間に合う。
Ｏ(N*K*W)としても解ける。

解説記事を読んでいたら重さか個数を逆順にすれば重複しないとあり、なるほどなとなった。

 ----解説ここまで---- */

ll N, W, K;
ll w[50], v[50];
ll dp[51][10001][51];

ll ans = 0LL;

int main()
{
    cin.tie(0);
    ios_base::sync_with_stdio(false);

    cin >> W >> N >> K;
    FOR(i, 0, N) {
        cin >> w[i] >> v[i];
    }

    FOR(i, 0, N) {//new
        FOR(j, 0, W + 1) {
            FOR(k, 0, K + 1) {
                if (j - w[i] < 0 || k - 1 < 0) {
                    dp[i + 1][j][k] = dp[i][j][k];
                }
                else {
                    dp[i + 1][j][k] = max(dp[i][j][k], dp[i][j - w[i]][k - 1] + v[i]);
                }
                ans = max(ans, dp[i + 1][j][k]);
            }
        }
    }

    cout << ans << endl;

    return 0;
}