#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

#define FOR(i,s,e) for(ll (i)=(s);(i)<(e);(i)++)
typedef long long ll;

/* -----  2017/02/27  Problem: ABC022 D / Link: http://abc022.contest.atcoder.jp/tasks/abc022_d ----- */
/* ------問題------

宇宙はビッグバンによって誕生して以来、膨張し続けていることが知られています。
天文学者である高橋君はその宇宙の膨張の速度を計測することにしました。
高橋君はある 2 つの日について、同じ N 個の星の位置を観測しました。星の位置は座標平面上の点として記録されます。
つまり各日の観測結果は座標平面上の N 個の点からなる点集合になります。
2 回の観測の結果を見比べてみると、1 回目の観測結果である点集合に対して以下の 3 つの操作を順に実行すると 2 回目の観測結果である点集合に一致することがわかりました。
同じ向きに同じ距離だけ平行移動する。
原点を中心に同じ角度だけ回転する。
原点を中心に P 倍 (1≦P) に相似拡大する。つまり点 (a,b) を点 (a×P,b×P) に移すという操作をすべての点に実行する。
ここで P の値がわかれば膨張速度を求めることができそうです。
いざ P を求めようとした高橋君でしたが、うっかりどの点がどの星に対応するのか記したデータをなくしてしまいました。
そこで高橋君は優秀なプログラマーであるあなたに助けを借りることにしました。
1 回目と 2 回目の観測結果が与えられるので P を求めてください。

-----問題ここまで----- */
/* -----解説等-----

星すべてでできる星座を考えたときに、これの形はすべての動作を通じて一緒。
従って重心から各点までの距離の比も膨張率と同じになる。
これをもとめておしまい。
ランダムな順番に並んでいるから特徴づけれないと思ったけど
他の人の解法も見てみたら重心から最近点か最遠点1点の比でもよかった。

 ----解説ここまで---- */

ll N;
ll ax[100000], bx[100000], ay[100000], by[100000];
double gax = 0.0, gay = 0.0, gbx = 0.0, gby = 0.0;
double ans;
int main()
{
    cin.tie(0);
    ios_base::sync_with_stdio(false);

    cin >> N;
    FOR(i, 0, N) {
        cin >> ax[i] >> ay[i];
        gax += ax[i]; gay += ay[i];
    }
    FOR(i, 0, N) {
        cin >> bx[i] >> by[i];
        gbx += bx[i]; gby += by[i];
    }
    gax = gax / N;
    gay = gay / N;
    gbx = gbx / N;
    gby = gby / N;

    double a = 0.0, b = 0.0;

    FOR(i, 0, N) {
        a += ((gax - ax[i])*(gax - ax[i]) + (gay - ay[i])*(gay - ay[i]));
        b += ((gbx - bx[i])*(gbx - bx[i]) + (gby - by[i])*(gby - by[i]));
    }
    ans = sqrt(b / a);
    printf("%.12f¥n", ans);

    return 0;
}