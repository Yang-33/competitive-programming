#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;
#define FOR(i, s, e) for (ll(i) = (s); (i) < (e); (i)++)

/* -----  2017/03/31  Problem: JOI予選 2008 5  / Link: http://www.ioi-jp.org/joi/2007/2008-yo-prob_and_sol/2008-yo-t5/2008-yo-t5.html  ----- */
/* ------問題------

IOI製菓では， 創業以来の伝統の製法で煎餅（せんべい）を焼いている． この伝統の製法は， 炭火で一定時間表側を焼き， 表側が焼けると裏返して， 炭火で一定時間裏側を焼くというものである．
この伝統を守りつつ， 煎餅を機械で焼いている． この機械は縦 R (1 ≦ R ≦ 10) 行, 横 C (1 ≦ C ≦ 10000) 列の長方形状に煎餅を並べて焼く．
通常は自動運転で， 表側が焼けたら一斉に煎餅を裏返し裏側を焼く．

ある日， 煎餅を焼いていると， 煎餅を裏返す直前に地震が起こり何枚かの煎餅が裏返ってしまった． 
幸いなことに炭火の状態は適切なままであったが， これ以上表側を焼くと創業以来の伝統で定められている焼き時間を超えてしまい， 煎餅の表側が焼けすぎて商品として出荷できなくなる． 
そこで， 急いで機械をマニュアル操作に変更し， まだ裏返っていない煎餅だけを裏返そうとした．
この機械は， 横の行を何行か同時に裏返したり縦の列を何列か同時に裏返したりすることはできるが， 残念なことに， 煎餅を１枚ごと裏返すことはできない．

裏返すのに時間がかかると， 地震で裏返らなかった煎餅の表側が焼けすぎて商品として出荷できなくなるので， 
横の何行かを同時に１回裏返し， 引き続き， 縦の何列かを同時に１回裏返して， 表側を焼きすぎずに両面を焼くことのできる煎餅， 
つまり， 「出荷できる煎餅」の枚数をなるべく多くすることにした． 横の行を１行も裏返さない，あるいは， 縦の列を１列も裏返さない場合も考えることにする． 
出荷できる煎餅の枚数の最大値を出力するプログラムを書きなさい．

地震の直後に， 煎餅が次の図のような状態になったとする． 黒い丸が表側が焼ける状態を， 白い丸が裏側が焼ける状態を表している．

-----問題ここまで----- */
/* -----解説等-----

Rが非常に小さいので全列挙し、その後各列について反転を行うか反転を行わないかを検討すればよい。
”制限時間が１０秒”なので 2^R*R*W≦10^8で間に合う。

----解説ここまで---- */

ll N;
ll R, W;
ll t[10][100005];
bool flag[10];
ll ans = 0LL;

int main() {
  cin.tie(0);
  ios_base::sync_with_stdio(false);

  cin >> R>>W;
  FOR(i, 0, R) {
      FOR(j, 0, W) {
          cin >> t[i][j];
      }
  }

  FOR(i, 0, ((1 << R) - 1)) {
      FOR(x, 0, R)flag[x] = false;
      FOR(j, 0, R) {
          if (i&(1 << j))flag[j] = true;
      }
      ll res = 0;
      FOR(x, 0, W) {
          ll temp = 0;
          FOR(y, 0, R) {
              if ((flag[y] && !t[y][x]) || (!flag[y] && t[y][x]))temp++;
          }
          if (temp < R - temp)res += R - temp;
          else res += temp;
      }
      ans = max(ans, res);
  }
  cout << ans << endl;

  return 0;
}
