#include <iostream>
using namespace std;

typedef long long ll;
#define FOR(i, s, e) for (ll(i) = (s); (i) < (e); (i)++)

/* -----  2017/03/27  Problem: JOI莠磯∈2007 6  / Link: http://www.ioi-jp.org/joi/2006/2007-yo-prob_and_sol/2007-yo-problems/2007-yo-t6/2007-yo-t6.html  ----- */
/* ------蝠城｡

太郎君の住んでいるJOI市は， 南北方向にまっすぐに伸びる a 本の道路と， 東西方向にまっすぐに伸びる b 本の道路により， 碁盤の目の形に区分けされている．

南北方向の a 本の道路には， 西から順に 1, 2, ... , a の番号が付けられている． また， 東西方向の b 本の道路には， 南から順に 1, 2, ... , b の番号が付けられている．
西から i 番目の南北方向の道路と， 南から j 番目の東西方向の道路が交わる交差点を (i, j) で表す．

太郎君は， 交差点 (1, 1) の近くに住んでおり， 交差点 (a, b) の近くのJOI高校に自転車で通っている．
自転車は道路に沿ってのみ移動することができる． 太郎君は， 通学時間を短くするため， 東または北にのみ向かって移動して通学している．

現在， JOI市では， n 個の交差点 (x1, y1), (x2, y2), ... , (xn, yn) で工事を行っている． 太郎君は工事中の交差点を通ることができない．

太郎君が交差点 (1, 1) から交差点 (a, b) まで， 工事中の交差点を避けながら， 東または北にのみ向かって移動して通学する方法は何通りあるだろうか．
太郎君の通学経路の個数 m を求めるプログラムを作成せよ．

-----問題ここまで----- */
/* -----解説等-----

高校数学で習った組み合わせDPなので、通れない場所を考慮して
いい感じに場合わけすればよい。
経路のテーブルを作成し、(1,1)=1として通行止めでない場所だけあたいを生成していけばよい。

----解説ここまで---- */


ll ans = 0LL;

int main() {
    cin.tie(0);
    ios_base::sync_with_stdio(false);
    int a, b, n;
    cin >> a >> b >> n;
    ll d[20][20];
    bool no[20][20];
    FOR(i, 0, 20)FOR(j, 0, 20)d[i][j] = no[i][j] = 0;
    FOR(i, 0, n) {
        int x, y; cin >> x >> y;
        no[x][y] = true;
    }

    FOR(i, 0, a + 1) {
        FOR(j, 0, b + 1) {
            if (i == 0 || j == 0) {
                d[i][j] = 0;
            }
            else if (no[i][j]) d[i][j] = 0;
            else if (i == 1 && j == 1)d[1][1] = 1;
            else d[i][j] = d[i - 1][j] + d[i][j - 1];
        }
    }

    //FOR(i, 0, a + 1) {
    //    FOR(j, 0, b + 1) {
    //        cout << d[i][j] << " ";
    //    }
    //    cout << endl;
    //}
    ans = d[a][b];
    cout << ans << endl;
    //cout << d[a-1][b-1] << endl;

    return 0;
}
